//{
//    readonly int cubesX = 16;
//    readonly int cubesY = 256;
//    readonly int cubesZ = 16;
//    List<Vector3> vertices;
//    List<int> triangles;
//    int[,,,] vertexIndexArray;

//    private void Start()
//    {



//        // Tripla egymásba ágyazott for ciklus a tér bejárásához
//        for (int x = 0; x < cubesX; x ++)   // X tengely
//            for (int y = 0; y < cubesY; y ++)   // Y tengely
//                for (int z = 0; z < cubesZ; z ++)   // Z tengely
//                {
//                    Vector3Int position = new(x, y, z);
//                    // Kocka nyolc sarkán lévő skaláris értékek kiolvasása
//                    float[] cube = new float[8]; 
//                    for (int i = 0; i < 8; i++) 
//                        cube[i] = SampleTerrain(position + Tables.CornerTable[i]); 
//                    // Skaláris értékek alapján a konfiguráció meghatározása
//                    int configIndex = GetCubeCongif(cube); 
//                    // Első és utolsó konfiguráció üres
//                    if (configIndex == 0 || configIndex == 255) continue; 
//                    // Ciklus a konfigurációban található élekhez (max 15 darab vertex)
//                    for (int vertexCounter = 0; vertexCounter < 15; vertexCounter++) 
//                    {
//                        // Él kiolvasása a konfiguráció alapján
//                        int edgeIndex = Tables.TriangleTable[configIndex, vertexCounter]; 
//                        // Ha nincs több él amin vertex van befejeződik a ciklus
//                        if (edgeIndex == -1) break;
//                        // Ha az adott élre már számoltunk ki vertex-et
//                        int redirect, index;
//                        if ((index = vertexIndexArray[x, y, z, edgeIndex]) != -1) 
//                        {
//                            // Index beillesztése
//                            triangles.Add(index); 
//                        }
//                        // Ha az X tengelyen van előző kocka ÉS van az adott élnek párja
//                        else if (x > 0 && (redirect = Tables.redirect[edgeIndex].x) != -1) 
//                        {
//                            // Index kiolvasása (X tengely)
//                            index = vertexIndexArray[x - 1, y, z, redirect]; 
//                            // Index bemásolása az adott pozícióba
//                            vertexIndexArray[x, y, z, edgeIndex] = index; 
//                            // Index beillesztése az adott háromszög egyik csúcsának
//                            triangles.Add(index); 
//                        }
//                        // Ha az Y tengelyen van előző kocka ÉS van az adott élnek párja
//                        else if (y > 0 && (redirect = Tables.redirect[edgeIndex].y) != -1) 
//                        {
//                            index = vertexIndexArray[x, y - 1, z, redirect];
//                            vertexIndexArray[x, y, z, edgeIndex] = index;
//                            triangles.Add(index);
//                        }
//                        // Ha az Z tengelyen van előző kocka ÉS van az adott élnek párja
//                        else if (z > 0 && (redirect = Tables.redirect[edgeIndex].z) != -1) 
//                        {
//                            index = vertexIndexArray[x, y, z - 1, redirect];
//                            vertexIndexArray[x, y, z, edgeIndex] = index;
//                            triangles.Add(index);
//                        }
//                        else // Ha nem volt előzőleg kiszámolt érték
//                        {
//                            // A metódus kiszámolja majd beilleszti a vertex-et és visszaadja az indexét
//                            vertexIndexArray[x, y, z, edgeIndex] = CalculateVertex(position, edgeIndex, cube);
//                        }
//                    }
//                }






//    }

//    int CalculateVertex(Vector3Int position, int edgeIndex, float[] cube)
//    {
//        Vector3 vert1 = Tables.CornerTable[Tables.EdgeTable[edgeIndex, 0]];
//        Vector3 vert2 = Tables.CornerTable[Tables.EdgeTable[edgeIndex, 1]];

//        Vector3 vertPos;
//        if (smoothTerrain)
//        {
//            float vert1Sample = cube[Tables.EdgeTable[edgeIndex, 0]];
//            float vert2Sample = cube[Tables.EdgeTable[edgeIndex, 1]];

//            float difference = vert2Sample - vert1Sample;
//#if _DEBUG
//            if (difference == 0)
//                Debug.Log("DIFFERENCE IS 0");
//#endif

//            difference = (terrainHeight - vert1Sample) / difference;

//            vertPos = vert1 + (vert2 - vert1) * difference;
//        }
//        else
//            vertPos = (vert1 + vert2) / 2f;

//        vertPos *= LOD;
//        vertPos += position;

//        vertices.Add(vertPos);
//        int vertexCount = vertices.Count;
//        triangles.Add(vertexCount - 1);

//        return (vertexCount - 1);
//    }

//    int GetCubeCongif(float[] cube)
//    {
//        int configIndex = 0;
//        for (int i = 0; i < 8; i++)
//            if (cube[i] > terrainHeight)
//                configIndex |= 1 << i;
//        return configIndex;
//    }

//    float SampleTerrain(Vector3Int point)
//    {
//        return terrainData[point.x, point.y, point.z];
//    }

//}
